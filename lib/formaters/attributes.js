const UUID = require('uuid');

export default function formatAttrs(
    opt,
    delay,
    _eventName,
    _isLoopEvent,
    proccessRuntime,
) {
    // initialize StreamEvent's options
    const AssignOpt = typeof opt === 'function'
        ? { handler: opt }
        : Array.isArray(opt)
            ? { eventList: opt }
            : opt;

    if (typeof delay === 'boolean') {
        _isLoopEvent = delay;
        _eventName = '';
        delay = 1000;
    }

    if (typeof _eventName === 'boolean') {
        _isLoopEvent = _eventName;
        _eventName = '';
    }

    if (typeof _eventName !== 'string') {
        _eventName = '';
    }

    // Can not to create an object options and throw an Error.
    if (typeof AssignOpt !== 'object' || !AssignOpt) throw new Error('First arguments must be Object, Function, or Array.');

    // initialize Readonly Data.
    const EventData = {
        name: _eventName || AssignOpt.name,
        repeat: AssignOpt.repeat,
        onProccess: AssignOpt.onProccess || false,
        createTime: proccessRuntime,
        runtime: 1,
        remainTimes: parseInt(AssignOpt.repeat, 10),
        isLoopEvent: false,
        delay: typeof delay === 'number' ? delay : AssignOpt.delay || 1000,

        created: AssignOpt.created || null,
        onclose: AssignOpt.onclose || null,
        handler: AssignOpt.handler || null,
        eventList: Array.isArray(AssignOpt.eventList) ? AssignOpt.eventList : [],
    };

    // if event name is not a String, it will use uuid generated by modules uuid.v4 instead.
    if (typeof EventData.name !== 'string') {
        EventData.name = UUID.v4().replace(/-/g, '');
    }

    // argument handler or eventList should contain at least one function otherwise will throw an Error.
    if (typeof EventData.handler !== 'function' && !EventData.eventList.length) {
        throw new Error(
            'Event Object should contain an excutionable Function at property handler or eventList.',
        );
    }

    // format remainTimes, when its value not positive Integers and use 1 instead.
    EventData.remainTimes = Number.isNaN(EventData.remainTimes)
        ? 1
        : Math.max(EventData.remainTimes, 0);

    // if Argument: opt is an Array, use its length as StreamEvent's remainTimes
    if (Array.isArray(opt)) {
        EventData.remainTimes = opt.length;
    }

    // make Attribute repeat same as remaintimes
    // remainTimes is base on Attribute repeat, when opt is an Array, remaintimes will match on opt's length
    // in case of Attribute:repeat not an intergers, it will use Attribute:remainTimes value that has been formatted.
    EventData.repeat = EventData.remainTimes;
    // when Attribute repeat is 0, StreamEvent will continually excute according to Attribute: delay
    EventData.isLoopEvent = EventData.repeat === 0;

    // if Argument _isLoopEvent is Boolean, then set Attribute: repeat follow the rules.
    // when Attribute: isLoopEvent is true, StreamEvent will continually excute,
    // othervise it will stop and remove itself when remainTimes go to zero.
    if (typeof _isLoopEvent === 'boolean') {
        EventData.repeat = _isLoopEvent ? 0 : EventData.repeat;
        EventData.isLoopEvent = _isLoopEvent;
    }

    return EventData;
}
